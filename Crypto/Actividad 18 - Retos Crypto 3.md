# Mini RSA

What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let's decrypt this: [ciphertext](https://mercury.picoctf.net/static/387dc6431820338cc74324cc5cc9550f/ciphertext)


RSA [tutorial](https://en.wikipedia.org/wiki/RSA_\(cryptosystem\))
How could having too small of an `e` affect the security of this key?
Make sure you don't lose precision, the numbers are pretty big (besides the `e` value)
You shouldn't have to make _too_ many guesses
`pico` is in the flag, but not at the beginning

1. Descargamos el archivo
```
wget https://mercury.picoctf.net/static/387dc6431820338cc74324cc5cc9550f/ciphertext
```

2. Revisamos lo que contiene el archivo
```
cat ciphertext

N: 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287

e: 3

ciphertext (c): 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962
```

3. Creamos un script en Python capaz de resolver el ejercicio, el cual explora la vulnerabilidad de RSA cuando se usa un exponente pequeño. En este caso, el mensaje cifrado se obtiene mediante la operación ( c = m^e \mod N ), pero debido a que ( e ) es pequeño, podemos aprovechar una técnica para recuperar el mensaje original.
```python
import math
from gmpy2 import iroot
from binascii import unhexlify

N = 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
e = 3
c = 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962

for i in range(1, 5000):
	cube_root, exact = iroot(c + (i*N), e)
	hexed = "{:x}".format(cube_root)
	if len(hexed) % 2 != 0:
		hexed = "0" + hexed
	message = unhexlify(hexed)
	if b"pico" in message:
		print(message)
		break
```

4. Obtenemos la bandera
```
python3 mini_rsa.py                                                                                                                 picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}
```



# Mind your Ps and Qs

In RSA, a small `e` value can be problematic, but what about `N`? Can you decrypt this? [values](https://mercury.picoctf.net/static/3cfeb09681369c26e3f19d886bc1e5d9/values)

Bits are expensive, I used only a little bit over 100 to save money

1. Descargamos el archivo
```
wget https://mercury.picoctf.net/static/3cfeb09681369c26e3f19d886bc1e5d9/values
```

2. Revisamos el archivo
```
cat values
Decrypt my super sick RSA:
c: 8533139361076999596208540806559574687666062896040360148742851107661304651861689
n: 769457290801263793712740792519696786147248001937382943813345728685422050738403253
e: 65537
```

3. Usamos una herramienta como https://www.dcode.fr/rsa-cipher para descifrar. Obtenemos la bandera
```
picoCTF{sma11_N_n0_g0od_45369387}
```



# b00tl3gRSA2

In RSA d is a lot bigger than e, why don't we use d to encrypt instead of e? Connect with `nc jupiter.challenges.picoctf.org 18243`.

What is e generally?

1. Nos conectamos al puerto
```
nc jupiter.challenges.picoctf.org 18243

c: 65148043676744206284005740238652444437134429211933597510728650345334461399028134192528488277441551998264923044477082866706244597427043838571983335952866461922784412085431015208005349361469621570364719486213101877842147233234289521100209495878228300980738665107817255358121879005215329010437190235565359354123
n: 115408444443175099103604977735212658925621026223287383508988907222483202661210933119928204804433955111738279127482235768457966441404919491729894502302125718341713063065439653279236064618754743162479481194274911336733994913220727019490999120562823926580292695188135544581842059205326898481275066967145298001121
e: 76920766310974434349216000617236433686773151753351789051316728815558978522733032784710681203937921986600542755505310597098012300334288849325625551292539367912969594635050386460238192704523738786969446881462523255456412838060684465030053673762586360291786468872067855338250234561890573841254428249011463434773
```

2. Usamos una herramienta como https://www.dcode.fr/rsa-cipher para descifrar. Obtenemos la bandera
```
picoCTF{bad_1d3a5_4783252}
```



# b00tl3gRSA3

Why use p and q when I can use more? Connect with `nc jupiter.challenges.picoctf.org 4557`

There's more prime factors than p and q, finding d is going to be different.

1. Nos conectamos al puerto
```
nc jupiter.challenges.picoctf.org 4557

c: 1944945335128125495233238640930592537882240665558874764119942146153169581965548020425820505692101534791499865329430899648791228058934977448003114579135102943827303239443129102992746590241502436651049197414437524464715893595808910298079576308441660270616488541488105352838999495860978230895625397572575066624915243076818559630283947682619085488
n: 3988553823098019690111173478289647410411867772257651503740179878043249700211555067975534847161723948550779130447545068456837825532409970355884310613358789518666963876616704842202744177276352412351105508031835560173261452389350075062484288008173075533919361488484845132678305169511984697345397405477580095858639804828613829629569895510958577439
e: 65537
```

2. Usamos una herramienta como https://www.dcode.fr/rsa-cipher para descifrar, pero obtenemos
```
��Õ�s��¯è>æ©Ã�-«QPj� �ûú��û¬ÔÝ���0éZó·�¢.Æ�»��KÌ�yø�  
�áµeJ°�ó'c�V«Í?#�µ�çq�^  
¸��è©ä.-�ñl (S7ßÊª®�7ÛÎ�ÿ�ü�íT  
°�á���j¡���FG�´ìi�$æ*�ÿfXf/y¿1�ÍMÅU
```

3. Usamos https://www.alpertron.com.ar/ECM.HTM para factorizar N y obtener la función de Euler
```
3 988553 811540 201712 884484 271717 473789 266882 617321 018473 396943 144722 695841 439216 012712 328829 458545 623064 397891 642991 493711 425178 169067 051985 127186 847695 536755 311287 107764 897379 141557 422282 989493 972917 880802 777928 691200 951748 997374 748720 097425 565142 029156 244487 024018 973974 710334 464245 574977 076842 806783 949114 416879 974588 874752 000000 000000 000000
```

2. Volvemos a intentar el paso 2, pero ahora agregamos el valor obtenido de la función de Euler en ``Intermediate value Phi (Integer) φ=``. Obtenemos la bandera
```
picoCTF{too_many_fact0rs_4025135}
```